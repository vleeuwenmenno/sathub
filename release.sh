#!/bin/bash

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Function to print colored output
print_color() {
    printf "${1}${2}${NC}\n"
}

# Function to get the latest tag
get_latest_tag() {
    git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0"
}

# Function to parse version components
parse_version() {
    local version=$1
    # Remove 'v' prefix if present
    version=${version#v}
    IFS='.' read -r major minor patch <<< "$version"
    echo "$major $minor $patch"
}

# Function to increment version
increment_version() {
    local major=$1
    local minor=$2
    local patch=$3
    local increment_type=$4

    case $increment_type in
        major)
            major=$((major + 1))
            minor=0
            patch=0
            ;;
        minor)
            minor=$((minor + 1))
            patch=0
            ;;
        patch)
            patch=$((patch + 1))
            ;;
        *)
            print_color $RED "Invalid increment type: $increment_type"
            exit 1
            ;;
    esac

    echo "$major.$minor.$patch"
}

# Function to get current version from files
get_current_version() {
    # Try to get version from frontend/src/version.ts first
    if [ -f "frontend/src/version.ts" ]; then
        version=$(grep "export const VERSION" frontend/src/version.ts | sed "s/.*VERSION = '\([^']*\)'.*/\1/")
        if [ -n "$version" ]; then
            echo "$version"
            return
        fi
    fi
    
    # Fallback to backend/version.go
    if [ -f "backend/version.go" ]; then
        version=$(grep "const VERSION" backend/version.go | sed "s/.*VERSION = \"\([^\"]*\)\".*/\1/")
        if [ -n "$version" ]; then
            echo "$version"
            return
        fi
    fi
    
    # Fallback to client/version.go
    if [ -f "client/version.go" ]; then
        version=$(grep "const VERSION" client/version.go | sed "s/.*VERSION = \"\([^\"]*\)\".*/\1/")
        if [ -n "$version" ]; then
            echo "$version"
            return
        fi
    fi
    
    # If all else fails, use the latest tag
    get_latest_tag | sed 's/^v//'
}

# Function to update version files
update_version_files() {
    local version=$1
    
    print_color $BLUE "Updating version files to $version..."
    
    # Update frontend version.ts
    cat > frontend/src/version.ts << EOF
// This file is auto-generated by the release script
// Do not modify manually
export const VERSION = '$version';
EOF
    
    # Update backend version.go
    cat > backend/version.go << EOF
// This file is auto-generated by the release script
// Do not modify manually
package main

const VERSION = "$version"
EOF
    
    # Update client version.go
    cat > client/version.go << EOF
// This file is auto-generated by the release script
// Do not modify manually
package main

const VERSION = "$version"
EOF
    
    # Update frontend package.json
    if command -v jq > /dev/null; then
        # Use jq if available for precise JSON editing
        jq --arg version "$version" '.version = $version' frontend/package.json > frontend/package.json.tmp && mv frontend/package.json.tmp frontend/package.json
    else
        # Fallback to sed
        sed -i "s/\"version\": \"[^\"]*\"/\"version\": \"$version\"/" frontend/package.json
    fi
    
    # Update client go.mod version comment (add version comment if needed)
    if ! grep -q "// version:" client/go.mod; then
        sed -i "1a\\// version: $version" client/go.mod
    else
        sed -i "s|// version:.*|// version: $version|" client/go.mod
    fi
    
    print_color $GREEN "âœ… Version files updated to $version"
}

# Main script
print_color $BLUE "ðŸš€ SatHub Release Script"
echo

# Check if we're in a git repository
if ! git rev-parse --git-dir > /dev/null 2>&1; then
    print_color $RED "Error: Not in a git repository"
    exit 1
fi

# Check for uncommitted changes
if ! git diff-index --quiet HEAD --; then
    print_color $RED "Error: You have uncommitted changes. Please commit or stash them first."
    exit 1
fi

# Get latest tag
latest_tag=$(get_latest_tag)
print_color $GREEN "Current latest tag: $latest_tag"

# Parse version
read -r major minor patch <<< "$(parse_version "$latest_tag")"
print_color $BLUE "Current version: $major.$minor.$patch"

# Ask for increment type
echo
print_color $YELLOW "What type of release would you like to make?"
echo "1) Patch (bug fixes) - $major.$minor.$((patch + 1))"
echo "2) Minor (new features) - $major.$((minor + 1)).0"
echo "3) Major (breaking changes) - $((major + 1)).0.0"
echo "4) Tag only (use existing version from files, no version update)"
echo
read -p "Enter your choice (1-4): " choice

case $choice in
    1)
        new_version=$(increment_version "$major" "$minor" "$patch" "patch")
        update_versions=true
        ;;
    2)
        new_version=$(increment_version "$major" "$minor" "$patch" "minor")
        update_versions=true
        ;;
    3)
        new_version=$(increment_version "$major" "$minor" "$patch" "major")
        update_versions=true
        ;;
    4)
        new_version=$(get_current_version)
        update_versions=false
        print_color $BLUE "Using existing version from files: $new_version"
        ;;
    *)
        print_color $RED "Invalid choice. Exiting."
        exit 1
        ;;
esac

new_tag="v$new_version"
print_color $GREEN "New tag will be: $new_tag"

# Handle version file updates based on the choice
if [ "$update_versions" = true ]; then
    # Ask about updating version files
    echo
    read -p "Would you like to update version files and commit them before creating the tag? (Y/n): " update_files_confirm
    if [[ ! $update_files_confirm =~ ^[Nn]$ ]]; then
        update_version_files "$new_version"
        
        # Check if there are changes to commit
        if ! git diff-index --quiet HEAD --; then
            print_color $BLUE "Committing version updates..."
            git add frontend/src/version.ts backend/version.go frontend/package.json client/version.go client/go.mod
            git commit -m "chore: bump version to $new_version"
            
            # Ask if we should push the commit
            read -p "Push the version commit to origin? (Y/n): " push_commit
            if [[ ! $push_commit =~ ^[Nn]$ ]]; then
                git push origin $(git rev-parse --abbrev-ref HEAD)
                print_color $GREEN "âœ… Version commit pushed"
            fi
        else
            print_color $YELLOW "No changes to commit (version files already up to date)"
        fi
    fi
else
    print_color $BLUE "Skipping version file updates as requested"
fi

# Confirm
echo
read -p "Are you sure you want to create and push tag $new_tag? (y/N): " confirm
if [[ ! $confirm =~ ^[Yy]$ ]]; then
    print_color $YELLOW "Release cancelled."
    exit 0
fi

# Create and push tag
print_color $BLUE "Creating tag $new_tag..."
git tag -a "$new_tag" -m "Release $new_tag"

print_color $BLUE "Pushing tag $new_tag..."
git push origin "$new_tag"

print_color $GREEN "âœ… Tag $new_tag created and pushed successfully!"

# Ask about creating a release
echo
read -p "Would you like to create a GitHub release now? (y/N): " create_release
if [[ $create_release =~ ^[Yy]$ ]]; then
    # Try to open GitHub releases page
    if command -v xdg-open > /dev/null; then
        xdg-open "https://github.com/vleeuwenmenno/sathub/releases/new?tag=$new_tag" 2>/dev/null &
        print_color $GREEN "Opened GitHub releases page in your browser."
    elif command -v open > /dev/null; then
        open "https://github.com/vleeuwenmenno/sathub/releases/new?tag=$new_tag" 2>/dev/null &
        print_color $GREEN "Opened GitHub releases page in your browser."
    else
        print_color $BLUE "Please visit: https://github.com/vleeuwenmenno/sathub/releases/new?tag=$new_tag"
    fi
else
    print_color $BLUE "You can create a release later at: https://github.com/vleeuwenmenno/sathub/releases/new?tag=$new_tag"
fi

print_color $GREEN "ðŸŽ‰ Release process complete!"